для запуска приложения необходимо:
в файле config/settings.py
EMAIL_HOST = 'smtp.mail.ru'
изменить адрес который будет использоваться
EMAIL_PORT = '465'                                      
изменить порт на который будет использоваться
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER')
создать переменную окружения это эл.адрес с которого будет происходить рассылка
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD')  
создать переменную окружения пароль доступа для стороннего приложения  

ДЗ 23.1
Задание 1

Создайте группу для роли модератора и опишите необходимые доступы:

    может отменять публикацию продукта,
    может менять описание любого продукта,
    может менять категорию любого продукта.

Что делаю:
1. Создаю новое поле в модели Product (is_moderated - продукт прошел модерацию и может быть опубликован на сайте
   по умолчанию False. Только группа модераторы может поменять)
2. Создаю кастомные разрешения для трех доступов из задания  
   permissions = [
            ('can_publish_product', 'Can publish product'),
            ('can_change_description', 'Can change description'),
            ('can_change_category', 'Can change category'),
        ]
3. Добавил в группу 2 пользователей с is_active True
4. Сделал форму для вывода информации модератору из 3 полей
5. Прописал логику выбора формы в view catalog

ВОПРОС
  - Все что идет через форм сет тоже выводится и модератор может изменять Это же не правильно??
  - Как избежать отображения формсета??










Задание 1

Создайте новое приложения для работы с пользователем. 
Определите собственную форму для пользователя, 
при этом задайте электронную почту как поле для авторизации.

Также добавьте поля:

    аватар,
    номер телефона,
    страна.

    Не забудьте откатить миграции приложения auth
    до внесения изменений в настройки проекта и переопределения модели для авторизации. 
    Если этого не сделать, вы не сможете взаимодействовать с базой данных. 
    Чтобы откатить миграции приложения auth , можно воспользоваться командой
    python manage.py migrate auth zero


Задание 2

В сервисе реализуйте функционал аутентификации, а именно:

    1. Регистрация пользователя по почте и паролю.
          Создайте контроллер для регистрации, который будет взаимодействовать с 
          формой регистрации — пользователю достаточно ввести почту и пароль.

    
    2. Верификация почты пользователя через отправленное письмо.

            В контроллере регистрации переопределите метод form_valid()
            и встройте автоматическую отправку электронного сообщения пользователю на 
            указанный в форме регистрации адрес.
            Для отправки электронной почты воспользуйтесь встроенной в Django функцией
            send_mail()

    3. Авторизация пользователя.
        
            Создайте отдельный контроллер для авторизации (LoginView) и зарегистрируйте его в приложении.

    4. Восстановление пароля зарегистрированного пользователя на автоматически сгенерированный пароль.
            Создайте новый контроллер для восстановления пароля.
            В интерфейсе кнопка «Восстановить пароль» должна отображаться на странице входа.
            Пользователь вводит адрес электронной почты, в контроллере происходит генерация пароля, 
            перезапись пароля для пользователя с соответсвующим адресом электронной почты и отправка сообщения 
            с новым паролем на адрес почты.
            Пароль можно сгенерировать с помощью библиотеки random

        .

            Помните, что пароль в базе данных хранится в захешированном виде. 
            Для установки пароля пользователю можно воспользоваться функцией
            make_password()
            (посмотреть в документации про эту функцию).

Задание 3

Все контроллеры, которые отвечают за работу с продуктами, закройте для анонимных пользователей, 
при этом создаваемые продукты должны автоматически привязываться к авторизованному пользователю.

    Чтобы закрыть контроллеры от анонимных пользователей, добавьте в CBV-контроллеры дополнительное наследование
    от LoginRequiredMixin.

    Не забудьте добавить поле для продуктов, которое будет указывать на владельца. Оно должно быть ссылкой на 
    модель пользователя. Для автоматической привязки пользователя к продукту переопределите в контроллере 
    создания продукта метод form_valid() .

    Текущий авторизованный пользователь доступен через self.request.user
    — запишите его в только что созданный продукт и не забудьте сохранить объект в базу данных.
